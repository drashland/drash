import { assertEquals } from "https://deno.land/std@0.158.0/testing/asserts.ts";
import { AbstractChainHandler } from "../../../../src/core/handlers/abstract/AbstractChainHandler.ts";
import { DrashRequest } from "../../../../src/core/http/drash_request.ts";
import { Types } from "../../../../mod.deno.ts";

Deno.test("ChainHandler", async (t) => {
  await t.step("handle()", async (t) => {
    await t.step("can handle a chain of given methods", async () => {
      const expectedResponseText = "YO!";
      const expectedResponseHeader = "GOODBYE!";

      class MyChainHandler extends AbstractChainHandler {
        #method_chain: Types.HandleMethod<Types.ContextForRequest, void>[] = [];

        constructor() {
          super();

          this.#method_chain.push((context: Types.ContextForRequest) => {
            context.response = new Response(expectedResponseText);
          });

          this.#method_chain.push((context: Types.ContextForRequest) => {
            context.request.headers.append("X-HELLO", expectedResponseHeader);
          });
        }

        public handle(
          context: Types.ContextForRequest,
        ): Types.Promisable<Response> {
          return Promise
            .resolve()
            .then(() => this.runMethodChain(context, this.#method_chain))
            .then(() =>
              context.response ??
                new Response("No response was generated by the server.")
            );
        }
      }

      const myChainHandler = new MyChainHandler();

      const context: Types.ContextForRequest = {
        request: new DrashRequest(
          new Request("http://localhost:1337/my-cool-url"),
        ),
      };

      const result = await myChainHandler.handle(context);

      assertEquals(
        await result.text(),
        expectedResponseText,
      );

      assertEquals(
        context.request.headers.get("X-HELLO"),
        expectedResponseHeader,
      );
    });
  });
});
